Streams - потоки
.stream() - создаёт отдельный поток элементов, то есть элементы коллекции копируются, и мы
уже работает не с самой коллекцией, а с потоком

.map() - проходит по всем элементам коллекции

.collect(Collectors.toList()) - собирает элементы потока в коллекцию List
.collect(Collectors.toSet()) - собирает элементы потока в коллекцию Set

.filter() - позволяет фильтровать коллекцию. Работает на интерфейсе Predicate, что
значит все элементы проходят проверку на true или false в соответствии проверке.

Для массива:
int[] array = {5,1,3,8,9};
Arrays.stream(array).map(element ->{
            if (element % 3 ==0){
                element /=3;

            }
            return element;
        }).toArray();


.reduce() - на выходе всегда получаем 1 элемент. Т.е. уменьшаем n-ое количество элементов до 1.
.sorted() - сортирует коллекцию/массив.

Методы делятся на Laze и Eager. Lazy методы не сработают без Eager метода. Eager методы : .forEach(), .collect()
Остальные методы Lazy.

.concat() - Выполняет конкатенацию, т.е. объединение двух коллекций.
.distinct() - Оставляет только уникальные элементы, убирает повторы
.count() - возвращает количество элементов, имеет тип long
.flatMap() - возвращает элементы из её коллекций. Т.е. элементы элементов.

Collectors.groupingBy() - группирует элементы по каким-то параметрам. На выходе получается Map
Collectors.partitioningBy() - разделяет на 2 группы по условию, true или false. На выходе получается Map

.findFirst() - возвращает первый элемент коллекции.
.min() - возвращает минимальный элемент. Необходим Comparator
.max() - возвращает максимальный элемент. Необходим Comparator
.limit() - ограничивает количество в стриме (steam), выводит первые n элементы
.skip() - пропускает первые n элементы, выводит элементы которые после пропущенных n элементов.
.mapToInt() - оставляет после себя int steam, stream содержащий int значения
.mapToDouble() - оставляет после себя double steam, stream содержащий double значения
.boxed() - преобразует элементы стрима из int в Integer. Упаковывает другими словами
.sum() - суммирует все элементы коллекции
.average() - возвращает среднее значение

ParallelStream - разбивает операцию на несколько операций и распределяет выполнение по процессорам.
Применять только если много операций и если порядок не важен. В ином случае получим неверный результат.
Например:
Сложение, тут порядок не важен : 1+2+3+4+5, или (1+2+3) + (4+5) = результат одинаковый
А вот при делении порядок важен: 10/5/1/0.25 = 8   и   (10/5) / (1/0.25) = 0.5   РЕЗУЛЬТАТ РАЗНЫЙ