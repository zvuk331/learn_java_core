Потоки можно создать так:
любой класс расширяющий класс Thread + переопределение метода run();

class AnyClass extends Thread{
    public void run(){
        do something...
    }
}

Второй получше способ: любой класс имплементирующий интерфейс Runnable +
переопределение run(), создаётся через Thread class в конструкторе:

class AnyClass implements Runnable {
    public void run(){
        do something...
    }
}

public static void main(String[] args){
    Thread thread = new Thread(new AnyClass());
    thread.start();
}

Запуск потока производится через метод start();
sleep(1000) - усыпить поток на 1 секунду;
join(5000)- дождаться поток поток завершит работу, или выполнить после 5 секунд;


Во время работы с потоками для быстрой работы переменные c main memory так же сохраняются в кэше процессора,
для быстрого обращения и работы.
переменные volatile хранятся только в main Memory, а не в кэше процессора.
Переменные volatile корректно работают только тогда, когда только 1 поток изменяет переменную, остальные только читают.

Data race - гонка потоков, это когда 2 потока обращаются к одной переменной.

synchronized - синхронизация, т.е. потоки будут по очереди работать. Достигается за счёт блокировки доступа
пока один поток работает с этим методом, другой не может с ним работать, он ждёт пока второй отдаст доступ.
Синхронизировать можно как метод, так и часть кода. Но сама блокировка доступа происходит только на классах
и объектах. Каждый класс и объект имеет монитор, который показывает состояние объекта класса открыт/закрыт.

wait()- усыпляет поток но не останавливает его, переводит в режим ожидания. Монитор не освобождает.
notify()- разрешает действовать второму потоку.

Deadlock- ситуация когда 2 и более потоков залочены навсегда, ожидают друг друга и ничего не делают.
Livelock - ситуация когда 2 и более потоков совершают какие-то действия, но без результата: Например
первый записывает данные, а второй сразу же их удаляет. Работа совершается, результата нет. И так может
длиться бесконечно.

Lock starvation - ситуация, когда менее приоритетные потоки ждут долгое время или всё время для того,
чтобы могли запуститься.

Итерфейс Lock и его наследник ReentrantLock исользуются для блокировки и разблокировки потоков.
методы lock() и unlock();
lock() - блокирует поток, после обязательно нужно его разблокировать, иначе метод навсегда будет заблокирован
unlock() - разблокировка.
tryLock() - возвращает boolean, пробует заблокировать поток, если у него не выходит то он продолжает работу но без кода
в блоке tryLock();

interrupt() - метод указывающий потоку что его хотят прервать, как в этом случае поток должен действовать это описывает
программист в блоке кода if(isInterrupt()){}, программист может отказать в прерывании, или задать логику прерывания.

awaitTermination(5, TimeUnit.SECONDS) - метод заставляет ждать основной поток пока весь пулл потоков не выполнит работу,
или пока не пройдёт 5 секунд.

ExecutorService executorService = Executors.newFixedThreadPool(5); - создание пулла из 5 потоков;
executorService.shutdown(); - прекращает работу, если не выполнить метод shutdown(), то executorService будет ждать
новых заданий.

executorService.execute(new ThreadPoolExample()); - добавление задания в пулл потоков чтобы они выполнили это задание.

Выполнение потоков по рассписанию:
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
        scheduledExecutorService.schedule(new ThreadPoolExample2(), 3, TimeUnit.SECONDS);
        scheduledExecutorService.shutdown();

Интерфейс Callable он как и Runnable создаёт поток, но его отличие в том что он имеет метод call(), который имеет
возвращаемый тип и может выбрасывать исключение.
Объект Future позволяет хранить результат потока интерфейса Callable, с помощью метода get();

Semaphore - это синхронизатор потоков. В его параметре указывается сколько операций/потоков будет выполняться
одновременно.
semaphore.acquire() - позволяет потоку занять операцию.
semaphore.release() - закрывает операцию, позволяет переключиться на другую операцию. Обязательно нужно выполнять
 Future<Long> futurePartSum = executorService.submit(task); submit - это вместо execute(), отличие в том, что
 submit() работает с возвращаемым типом.

CountDownLatch - замок с обратным отсчётом.
CountDownLatch - это синхронизатор, позволяющий любому количеству потоков ждать пока не завершится определённное
количество операций. В конструктор CountDownLatch нужно передавать количество операций,которые должны завершиться,
чтобы потоки продолжили свою работу. Классная вещь, она позволяет отсрочить работу потоков пока не выполнятся нужные
методы.

Exchanger - это синхронизатор, позволяющий обмениваться данными между двумя потоками, обеспечивает то, что оба
потока получают информацию друг от друга одновременно.

AtomicInteger - это класс, который позволяет работать с целочисленным значением int, используя атомарные операции;
atomicInteger.incrementAndGet() - увеличивает значение на 1 и возвращает.
AtomicInteger используется если мы хотим изменять одну переменную в нескольких потоках, благодаря этому классу всё
будет работать как надо, а он в свою очередь работает за счёт атомарных операций.
Кроме AtomicInteger  есть так же и AtomicLong, AtomicDouble и т.д. и все они работают со своим типом.

Collections.synchronizedList(new ArrayList<>()) - для содания синхронизированных коллекций, работает на основе обычных
коллекций.
Чтобы работать с одной коллекцией в двух потоках нужно коллекцию поместить в synchronized блок кода.

ConcurrentHashMap - это синронизированная коллекция Map
ConcurrentHashMap имплементирует интерфейс ConcurrentMap который в свою очередь имплементирует Map.
В ConcurrentHashMap любое количество потоков может читать элементы не блокируя его.
В ConcurrentHashMap, благодаря его сегментированию, при изменении какого-либо элемента блокируется только bucket,
в котором он находится.

CopyOnWriteArrayList - синхронизированный ArrayList. Очень хорошо когда в основном чтение, а удаление/добавление по
минимуму. Желательно избегать большого количества удалений/добавлений. При изменении списка CopyOnWriteArrayList создаёт
копию списка.